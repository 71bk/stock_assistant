# 專案架構書（投資助理平台）
> 檔名：**專案架構書.md**  
> 版本：v2（新增：可選 Python AI Worker（OCR/RAG ingestion/回測）+ 介面/部署補齊）。
- **MongoDB：目前不需要**（Redis + Postgres(JSONB) 足夠）。

### 2.3 圖表（股票 API）
- 前端不直打第三方股票 API；**統一打後端 `/api/stocks/*`**。
- 後端代理第三方 API、做 **Redis cache + rate limit**、回傳正規化資料（quote/candles）。
- 圖表頁疊加個人資料：平均成本線、買賣點、損益等（來自 trades/positions）。

### 2.4 OCR 匯入交易
- OCR 不是只做文字：**OCR + AI 解析成「交易草稿 draft trades」**。
- 使用者在 OCR Review 頁可編輯/勾選/確認。
- confirmed 後才入帳到交易表，並更新持股彙總（positions），圖表立刻顯示買賣點。

### 2.5 AI 分析 / RAG
- AI 分析在圖表頁一鍵觸發，透過 **SSE 串流回覆**。
- 長期記憶以 **RAG（pgvector）**實作：快照/筆記/報告可向量化，Chat 頁可問並附 citations。

### 2.6 Whisper（語音）
- 目前需求主線以 OCR/交易/圖表/AI 為主，**Whisper 非必需**。
- 未來若要語音記帳/語音筆記，可新增 speech 模組，不影響現架構。

### 2.7 多市場（台股 + 美股）與商品唯一鍵
- 全站商品改用 `instrument_id`（UUID）做主鍵；對外顯示仍可用 `symbol/ticker`。
- 商品唯一鍵（建議）：`symbol_key = {market}:{exchange}:{ticker}`，例如：`US:XNAS:AAPL`、`TW:TWSE:2330`。
- 需支援 ticker 變體：如 `BRK.B` vs `BRK-B`，以 `instrument_aliases` 做對照。
- 後端統一存時間為 `UTC`，市場時區只用來算「是否開盤」與前端顯示。

### 2.8 幣別/匯率與資產顯示基準
- 只要納入美股，就會出現多幣別（TWD/USD）資產；必須引入 `fx_rates`。
- 使用者設定 `base_currency`（預設 TWD）；資產總覽一律換算到 base currency。
- 報酬可拆成：**標的漲跌貢獻** vs **匯率貢獻**（進階，可後做）。

### 2.9 公司行為（Corporate Actions）
- 至少要處理：**拆股/併股（split）**，否則持倉股數與平均成本會失真。
- 進階可加：股利（dividend）、ticker 更名（rename）、合併/分拆（merger/spinoff）。

### 2.10 即時串流選型（SSE 優先，WS 後補）
- AI 文字串流維持 SSE（穿透性好、實作簡單）。
- 若未來要做到「聊天室雙向互動 / 多人協作 / 盤中推播」再導入 WebSocket（需處理握手鑑權、心跳、重連）。

### 2.11（新增）Python AI Worker（可選，但最推薦用在 OCR / Ingestion）
> 定位：**不改變主線 Java 架構**，把「影像/文件/批次資料處理」抽成獨立服務，讓你更容易把 OCR 與 RAG ingestion 做到穩定且高品質。

**什麼情況需要加？**
- OCR 品質想拉高：去噪/裁切/旋轉、表格結構還原、不同券商版型對齊、數字/日期/單位校正
- RAG ingestion 想做得更好：PDF/HTML/Docx 清理、章節式 chunking、批次 embedding、去重與重試
- （可選）股票分析/回測：大量歷史資料的指標計算與回測（pandas/numpy 生態更省時）

**服務介面（建議）**
- `POST /ocr`：輸入 image/pdf（或 file_id / presigned url）→ 回傳 `raw_text + parsed_json + confidence`
- `POST /ingest`：輸入文件（或 file_id）→ 執行 parse/chunk/embed → 寫入 pgvector（或回傳 chunks 交由後端寫入）
- `POST /backtest`（可選）：輸入策略參數 → 回傳績效摘要/曲線資料

**與後端互動方式（兩種都可）**
1) **同步（最簡單）**：Backend 直接呼叫 ai-worker（適合小檔/短任務）
2) **非同步（更穩）**：Backend 建立 `ocr_jobs/ingest_jobs` → 丟 Redis Streams（`ocr:queue`/`ingest:queue`）→ ai-worker 消費 → 回寫 Postgres + 更新 job 狀態


---

## 3. 系統總體架構

### 3.1 架構圖（邏輯）
```mermaid
flowchart LR
  FE[Frontend\\nReact + Ant Design] -->|HTTPS /api| BE[Backend\\nSpring Boot 3]
  BE -->|SQL| PG[(PostgreSQL\\napp + vector schema)]
  BE -->|Cache/State| RD[(Redis)]
  BE -->|Proxy| STOCK[3rd-party Stock API]
  BE -->|HTTP/gRPC (sync) 或 Queue (async)| AIW[AI Worker (可選)\nFastAPI + Python]
  AIW -->|OCR Engine| OCR[OCR Provider/Engine]
  AIW -->|LLM/Embeddings| AI[LLM/Embedding Provider]

  subgraph PGX[PostgreSQL]
    PG_APP[(schema: app)]
    PG_VEC[(schema: vector + pgvector)]
  end
  PG --> PGX
```

### 3.2 核心資料流
1. **Google-only 登入**：Google → Backend 驗證 → 建/找 user → 發 access/refresh。
2. **交易/持股**：Trade（BUY/SELL）→ 重新計算 Position（avg_cost/qty）→ Portfolio/Chart。
3. **圖表**：Backend 代理股票 API + Redis 快取 → 前端畫圖；疊加成本線/買賣點。
4. **OCR 匯入**：Upload → OCR → AI parse → draft trades → Review → confirmed → 入帳 trades → 更新 positions。
5. **AI 分析（SSE）**：行情摘要 + 持股成本 → LLM → SSE 串流 → 可存 report。
6. **RAG**：快照/筆記/報告 → chunk + embedding → pgvector → Chat 檢索 + citations。

---

## 4. 後端：Maven Multi-Module（功能分 module）

### 4.1 模組清單與責任
- `app-bootstrap`：啟動/組裝（最終打包成一個後端應用）。
- `app-api`：Controller、API DTO/VO、全域錯誤處理、Swagger/OpenAPI。
- `app-auth`：Google-only 登入、JWT/Session、安全設定、`users` 維護。
- `app-portfolio`：交易/持股核心（trades、positions、watchlist）。
- `app-stocks`：股票 API proxy + **商品主檔（markets/exchanges/instruments/aliases）** + Redis cache + rate limit。
- `app-ocr`：OCR jobs、結果、draft trades、匯入交易（呼叫 portfolio service）。
- `app-files`：檔案上傳與 Object Storage（local/S3/MinIO）、`files` 表與權限（signed URL/中轉）。
- `app-ai`：SSE 串流、分析/報告、Prompt 管理。
- `app-rag`：chunk/embedding、向量寫入、TopK 檢索、citations。
- `app-common`：跨模組穩定共用（ApiResponse、ErrorCode、BusinessException、Clock/Id…）。
- `app-persistence`：DB/transaction、MyBatis/JPA 設定、type handlers、migration 配置。

### 4.2 介面抽象（Ports & Adapters）
> 抽成介面以低耦合、可替換供應商/實作。

建議必抽的 Port：
- `StockMarketClient`（股票資料來源）
- `OcrEngine`（OCR 引擎）
- `LlmClient`（LLM 分析/結構化）
- `EmbeddingClient`（Embedding）
- `VectorStore`（向量儲存/檢索）
- `ObjectStorage`（上傳檔案儲存：local/S3/MinIO）
- `FxRateProvider`（匯率來源：USD/TWD…）
- `CorporateActionProvider`（公司行為來源：拆股/股利/更名…）
- `CacheService/RateLimiter`（Redis 快取/限流）
- `CurrentUserProvider`（取得當前 user，隔離 Spring Security 細節）
- `ClockProvider/IdGenerator`（測試友善）


（新增）若導入 **ai-worker（Python）**，建議的 Adapter 對應：
- `OcrEngine` → `AiWorkerOcrAdapter`（呼叫 ai-worker `/ocr`；或由 ai-worker 直接呼叫雲端 OCR）
- `EmbeddingClient` → `AiWorkerEmbeddingAdapter`（批次 embedding/入庫）或維持由後端直連 embedding provider
- `VectorStore`：兩種擇一（**二選一即可**）
  - A) 後端寫入 pgvector（ai-worker 回傳 chunks + embeddings）
  - B) ai-worker 直接寫 pgvector（後端只管 job/metadata）


---

## 5. 後端資料夾結構（最外層含 Docker）

> 下面是「可直接照抄」的總體結構（與本次對話一致）。

```text
invest-assistant-backend/
├─ README.md
├─ pom.xml
├─ .github/
│  └─ workflows/
│     ├─ ci.yml
│     └─ deploy.yml
├─ infra/
│  ├─ docker-compose.yml
│  ├─ ai-worker/            # (可選) Python FastAPI：OCR/ingest/backtest
│  │  ├─ Dockerfile
│  │  └─ app/
│  ├─ nginx/conf.d/default.conf
│  ├─ postgres/init/
│  │  ├─ 001_schema.sql
│  │  ├─ 002_extensions.sql
│  │  └─ 003_tables.sql
│  ├─ redis/redis.conf
│  └─ scripts/up.sh
├─ docs/
│  ├─ architecture.md
│  ├─ api-contract.md
│  └─ db-schema.md
└─ modules/
   ├─ app-bootstrap/
   ├─ app-common/
   ├─ app-persistence/
   ├─ app-api/
   ├─ app-auth/
   ├─ app-portfolio/
   ├─ app-stocks/
   ├─ app-ocr/
   ├─ app-ai/
   └─ app-rag/
```

---

## 6. 技術選型（資料存取層）
- 建議組合：**JPA（auth/users） + MyBatis-Plus（大量 CRUD/分頁） + 手寫 SQL（pgvector/JSONB 深度查詢）**
- 也可全 MyBatis-Plus（更一致），但 auth 需自行把 security glue 寫完整。

---

## 7. Entity / DTO / VO / Enum 放置規範（乾淨做法）

### 7.1 放置原則
- **Entity**：放在各自功能 module（不要丟到 common）。
- **API DTO/VO**：放 `app-api`（做為對外合約 contract）。
- **模組內部 Command/Query/DTO**：放各自 module（application 層）。
- **跨模組穩定共用**：放 `app-common`（如 ErrorCode、ApiResponse、ClockProvider…）。

### 7.2 Enum 最乾淨的做法
- **DB 永遠存字串 code（EnumType.STRING / varchar）**，不要存 ordinal。
- enum 只負責 code（狀態/類型），**不要放顯示文字**。
- UI 顯示（label/i18n）在前端處理（或 dictionary mapping）。
- enum 放在「擁有語意」的 module；跨模組才放 common（例如 `ErrorCode`）。

---

## 8. 全域回傳 / 全域錯誤 / Swagger（放置與規範）

### 8.1 全域回傳格式
- `app-common`：`ApiResponse<T>`, `PageResponse<T>`
- `app-api`：可選 `ResponseBodyAdvice` 自動包裝（**需排除 SSE、檔案下載**）

### 8.2 全域錯誤處理
- `app-common`：`BusinessException`, `ErrorCode`
- `app-api`：`@RestControllerAdvice`（`GlobalExceptionHandler`）

### 8.3 Swagger / OpenAPI
- 建議使用 **springdoc-openapi**
- 放在 `app-api`：
  - OpenAPI 設定
  - 分組（auth/portfolio/stocks/ocr/ai/rag）
- SSE endpoint 可標註或從 UI 分組中適當處理（避免 UI 誤導）。

---

## 9. 資料庫設計概覽（PostgreSQL）

### 9.1 Schema
- `app`：業務資料
- `vector`：向量資料（pgvector extension）

### 9.2 多市場（台股 + 美股）主檔（必備）
- `app.markets`：`id`, `code(US/TW)`, `name`, `timezone`, `default_currency`
- `app.exchanges`：`id`, `market_id`, `mic`（如 XNAS/XNYS）, `name`
- `app.instruments`：
  - `id (uuid)`
  - `market_id`, `exchange_id`
  - `ticker`（AAPL/2330）, `symbol_key`（US:XNAS:AAPL）
  - `name`, `currency(USD/TWD)`, `status(ACTIVE/DELISTED)`, `created_at`
- `app.instrument_aliases`：`id`, `instrument_id`, `provider`, `alias`（BRK.B/BRK-B…）, `created_at`

> 建議 trades/positions 都只存 `instrument_id`；`symbol_key`/`ticker` 只當顯示或快取欄位。

### 9.3 行情與匯率
- `app.prices`：`instrument_id`, `ts_utc`, `interval(1d/1h/1m...)`, `open/high/low/close/volume`, `source`
- `app.fx_rates`：`base_currency`, `quote_currency`, `ts_utc`, `rate`（例如 base=TWD, quote=USD）

### 9.4 交易/持倉（Portfolio）
- `app.users`：`id(uuid)`, `google_sub(unique)`, `email`, `name`, `picture_url`, `base_currency`, `created_at`, `last_login_at`
- `app.portfolios`（可選，建議保留擴充）：`id`, `user_id`, `name`, `created_at`
- `app.stock_trades`（或 `app.trades`）：
  - `id`, `user_id`, `portfolio_id(optional)`
  - `instrument_id`
  - `side(BUY/SELL)`, `price`, `quantity`, `currency`, `fee`, `tax`
  - `executed_at_utc`（或 trade_date + time）
- `app.user_positions`（或 `app.positions`，可做快取表）：
  - `user_id`, `portfolio_id(optional)`, `instrument_id`
  - `total_quantity`, `avg_cost_native`, `currency`, `updated_at`
- `app.cash_ledger`（可選，做股利/手續費/入金出金會很方便）：`id`, `user_id`, `portfolio_id`, `currency`, `amount`, `type`, `ts_utc`

### 9.5 公司行為（Corporate Actions）
- `app.corporate_actions`：`id`, `instrument_id`, `action_type(SPLIT/DIVIDEND/RENAME/...)`, `ex_date`, `effective_date`, `payload(jsonb)`
- **MVP 最少要先做 SPLIT**：`payload` 內含 `ratio_from`, `ratio_to` 或 `split_ratio`。

### 9.6 OCR / AI 報告 / 檔案
- `app.files`：`id`, `user_id`, `provider(local/s3/minio)`, `bucket`, `object_key`, `sha256`, `size`, `content_type`, `created_at`
- `app.ocr_jobs`：`id`, `user_id`, `status`, `file_id(FK)`, `created_at`, `updated_at`
- `app.ocr_results`：`job_id`, `raw_text`, `parsed_json(jsonb)`
- `app.ocr_draft_trades`：`id`, `job_id`, `user_id`, `draft_json(jsonb)`, `status(DRAFT/CONFIRMED/REJECTED)`
- `app.ai_reports`：`id`, `user_id`, `instrument_id`, `input_summary(jsonb)`, `output_text`, `created_at`

#### 9.6.1 匯入 Staging（OCR / 手動輸入共用一條管線）
> 目的：先存「草稿」，讓使用者在 Review 頁校對；Confirm 後才寫入 `stock_trades` 並更新 `user_positions`（可追溯、可去重、可重跑）。

- `app.statements`：一份匯入批次（source=OCR/MANUAL），關聯 `file_id`（OCR 才有）
- `app.statement_trades`：匯入的交易列（含 `row_hash`、`errors_json/warnings_json`）
- `app.statement_holdings`：匯入的庫存列（對帳/比對用，v1 可不影響 positions）
- `app.statement_dividends`（可選）：股利列（或併入 `corporate_actions`）

建議把 OCR 與手動輸入都做成：
- Parse → 寫入 statement_*（DRAFT）
- Review → 使用者可修改（仍在 statement_*）
- Confirm → 寫入正式交易表 + 更新 positions（並把 statement 標記 CONFIRMED）

#### 9.6.2 民國日期（ROC）自動轉西元（AD）規範
- DB 一律存 **西元 `DATE` / `TIMESTAMP`**（ISO）
- 匯入解析時支援：
  - `YYYYMMDD`（西元 8 碼）
  - `YYYMMDD`（民國 7 碼，西元年 = 民國年 + 1911）
  - `YYYMM`（民國 5 碼）→ v1 可自動補日 `01`，並寫入 `warnings_json`


向量表（`vector`）：
- `vector.documents`：`id`, `user_id`, `type`, `source_id`, `created_at`
- `vector.chunks`：`id`, `document_id`, `user_id`, `content`, `embedding vector(n)`

> 向量資料務必帶 `user_id`，避免檢索到他人資料。

### 9.7 索引與唯一性（建議）
- `instruments(symbol_key)` unique
- `prices(instrument_id, interval, ts_utc)` unique
- `fx_rates(base_currency, quote_currency, ts_utc)` unique
- `instrument_aliases(provider, alias)` index + `instrument_id` FK

---

## 10. Redis 使用策略（短期與快取）
### 10.1 行情快取（cache）
- Quote：`stocks:quote:{symbol_key}`（TTL：3~10s，視資料源限制）
- Candles：`stocks:candles:{symbol_key}:{interval}:{from}:{to}`（TTL：30s~5m）

### 10.2 Rate limit
- `rate:{userId}:{endpoint}`（TTL：1m）
- `rate:ip:{ip}:{endpoint}`（TTL：1m，可選）

### 10.3 OCR/AI Job 狀態（MVP）
- `ocr:job:{userId}:{jobId}`（TTL：24h）
- `ai:job:{userId}:{jobId}`（TTL：24h）

### 10.4 佇列、重試、去重（建議 v1 補齊）
- Queue（可選）：Redis Streams `ocr:queue` / `ai:queue`（consumer group）
- Retry：失敗時 `retry_count + next_run_at`（也可先只做固定次數重試）
- 去重（idempotency）：`ocr:dedupe:{userId}:{fileSha256}`（TTL：7d），避免同檔重送造成重覆入帳


### 10.5 Auth Session（Refresh 存活/撤銷/旋轉）
- `sess:refresh:{jti}`（TTL=refresh 到期時間）：
  - value/hash fields：`userId`, `sessionId(optional)`, `expiresAt`
- （可選）`sess:user:{userId}`（SET）：該使用者所有有效 jti，用於「全裝置登出」
- （可選）`bl:access:{jti}`（TTL=access 到期）：若你要做到「登出立刻讓 access 失效」


---

## 11. 前端頁面（MVP 與進階）

### 11.1 MVP（約 10 頁）
1. Landing（首頁）
2. Auth Callback（Google 回跳）
3. Dashboard（總覽）
4. Portfolio（我的持股）
5. Trades（交易列表）
6. Trade Form（新增/編輯交易）
7. Chart（圖表：行情 + 成本線 + 買賣點 + AI）
8. AI Analysis（可做成 Chart 右側面板/抽屜）
9. OCR Upload（上傳）
10. OCR Review（交易草稿編輯/確認匯入）
（可選）Settings

### 11.2 進階（再加）
- Alerts（提醒/警示）
- Snapshots（快照）
- Notes（筆記）
- Chat（RAG 問答）

---

## 12. CI/CD + Docker 部署概覽
- `docker compose up -d` 一鍵啟動：
  - backend
  - postgres（含 pgvector）
  - redis
  -（可選）ai-worker（Python FastAPI：OCR/ingest/backtest）
  -（可選）nginx / n8n
- GitHub Actions：
  - CI：build + test
  - Deploy：build image → push registry → SSH 到主機 → `docker compose pull && docker compose up -d`

---

## 13. 里程碑建議（最小可交付）
0) 多市場主檔（markets/exchanges/instruments/aliases）+ `symbol_key` 規範（先把美股納進來）  
1) Google-only 登入 + user_id 隔離 + CORS/Cookie 規範  
2) Trades/Positions（手動新增交易，成本法先用加權平均）  
3) Stocks Proxy + Chart（含成本線/買賣點；時間一律 UTC）  
4) FX 匯率（USD/TWD）+ 資產總覽換算到 base_currency  
5) OCR 匯入（draft → review → confirm → 入帳；含去重/重試）  
6) AI 解讀（SSE + report 保存）  
7) 公司行為（先做 SPLIT）  
8) RAG（pgvector）與 Chat（可後做）

---

## 14. 附錄：模組間依賴規則（避免環狀）
- `app-api` 只依賴各模組提供的 service（或 application facade）。
- `app-ocr` 匯入交易時，呼叫 `app-portfolio` 的 service（不要直接寫 trades 表）。
- `app-common` 不依賴任何業務模組；業務模組可依賴 `app-common`。
- `app-bootstrap` 依賴全部（組裝）。

---

## 15. 安全與跨網域策略（Cookie / CORS / CSRF）
### 15.1 建議的網域切分（避免 Cookie 干擾）
- 前端：`https://app.xxx.com`（或 `https://xxx.com`）
- 後端：`https://api.xxx.com`
- **避免把後端 Cookie 的 Domain 設成過大的範圍**（例如 `.xxx.com`）而影響其他子站；若必須共享登入才設 `.xxx.com`。

### 15.2 Cookie 建議（若你用 cookie-based auth）
- `HttpOnly=true`, `Secure=true`（HTTPS 必開）
- SameSite：
  - 同站（app/api 同 eTLD+1 不跨站）：通常 `Lax` 可行
  - 若遇到跨站 OAuth callback / 第三方嵌入：改 `None` + `Secure`
- Path：把 refresh token cookie 限縮到 `/api/auth/refresh`（降低污染面）

### 15.3 CORS 建議（SPA 常見）
- 允許白名單 origins（不要用 `*` + credentials）
- `allowCredentials=true`（若需要送 cookie）
- SSE：確保 Nginx 不做 buffering（`proxy_buffering off`），並調大 `proxy_read_timeout`。

### 15.4 CSRF（只在你使用 cookie 帶 access token 時需要）
- 建議做法：access token 走 `Authorization: Bearer`；refresh token 才放 cookie（CSRF 風險較可控）。
- 若 access token 也放 cookie：需加 CSRF token（double submit 或 server-side token）。


### 15.5 Token 方案（本次對話定案：Access/Refresh 都放 HttpOnly Cookie + Refresh 狀態落 Redis）
- Cookie：
  - `access_token`：短效（建議 5~15 分鐘），HttpOnly/Secure/SameSite 依網域而定
  - `refresh_token`：長效（建議 7~30 天），HttpOnly/Secure，**Path 限縮到 `/api/auth/refresh`**
- Redis：只存 **refresh token 的 jti（token id）/session 狀態**，用來做撤銷、旋轉與偵測重放（不要把整顆 token 明文存 Redis）
- API：
  - `POST /api/auth/refresh`：使用 refresh cookie 換新 access（並旋轉 refresh）
  - `POST /api/auth/logout`：刪除 cookie + 撤銷 Redis refresh session（可做單裝置或全裝置）

### 15.6 Refresh Rotation（防盜用必做）
- 登入/refresh 成功後都產生新的 refresh（R2），並 **失效舊 refresh（R1）**
- Redis key 建議：`sess:refresh:{jti}`（TTL=refresh 到期）
  - 若 refresh 帶來的 jti 查不到 → 視為過期/撤銷/疑似被盜，用 401 拒絕


---

## 16. 交易與持倉計算規則（含公司行為）
### 16.1 成本法（v1 建議定案：加權平均）
- BUY：`new_qty = old_qty + qty`；`new_avg = (old_avg*old_qty + (price*qty + fee + tax)) / new_qty`
- SELL：`new_qty = old_qty - qty`；avg_cost 不變（實現損益可另算/另存）
- 若要支援「更正/刪除交易」：建議提供一個 rebuild job（從 trades 重新回算 positions）。

### 16.2 公司行為最小支援：拆股（SPLIT）
- 當 `split_ratio = 2:1`：`qty = qty * 2`；`avg_cost = avg_cost / 2`（同幣別下）
- 建議在匯入公司行為後，對受影響標的做一次 positions rebuild。

### 16.3 幣別換算（資產總覽）
- 每個 position 有 native currency（USD/TWD）。
- 顯示時：`value_base = value_native * fx(base_currency <- native_currency)`（匯率使用同日或最近的 ts_utc）。

---

## 17. 檔案儲存（Object Storage）落地
### 17.1 實作選項
- Dev：local filesystem（最簡單）
- Prod：MinIO（自架 S3 相容）或 AWS S3（託管）

### 17.2 File Model（files 表）與引用方式
- 任何上傳檔（OCR 圖片、PDF、報告附件）都先落 `app.files`，其他表只存 `file_id`。
- 以 `sha256` 做去重與追蹤（也可用於 OCR idempotency）。

### 17.3 上傳流程建議
- 最省事：後端提供 upload API（multipart），由後端寫入 storage。
- 更省後端流量：signed URL（前端直傳），後端只做「建立檔案紀錄 + 回寫 object_key」。

---

## 18. SSE vs WebSocket（選型與規格）
### 18.1 v1 建議：AI 串流維持 SSE
- 優點：HTTP 友善、穿透性好、前端實作簡單。
- 缺點：單向（server → client），但對「AI 回覆串流」已足夠。

### 18.2 未來何時導入 WebSocket
- 需要：雙向聊天室、多人協作、盤中推播大量事件、語音/即時互動。
- 導入時需補：握手鑑權、心跳、斷線重連、訊息序列號、限流。

---

> 若要下一步落地：可產出  
> ① DB migrations（Flyway） ② API 清單（OpenAPI） ③ 各 module 的 pom 依賴樹 ④ Docker compose 範本（pgvector+redis+nginx）
